# -*- coding: utf-8 -*-
"""Copia de TAREA 1 OFICIAL ALGORITMOS

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q8XbdNbAKeWLjpq-xJB_tavUOSUht1Ds

# CC3001 Oto√±o 2023 Tarea 1 [Gabriela Urbina Gonz√°lez]

# Pilas de arena abelianas

### Profesores
Secci√≥n 1 Iv√°n Sipir√°n ‚Ä¢
Secci√≥n 2 Patricio Poblete ‚Ä¢
Secci√≥n 3 Nelson Baloian

# Introducci√≥n
El objetivo de esta tarea es estudiar un problema inspirado en un fen√≥meno f√≠sico, a trav√©s de un modelo matem√°tico, el cual si bien es sencillo, produce resultados que presentan una estructura muy interesante.

<img src="https://ivan-sipiran.com/downloads/arena.png" alt= ‚Äú‚Äù width="200">

La idea es que si uno va formando una pila de arena, llega un momento en que se produce un derrumbe, y la arena de esa pila se derrama hacia los lugares vecinos, estos a su vez se pueden derrumbar, y el proceso contin√∫a hasta que finalmente se estabiliza.

Para estudiar este proceso, usaremos un modelo ultra simplificado. Supondremos que la arena se deposita sobre una superficie plana, la cual est√° dividida en peque√±as celdas cuadradas, las cuales forman un tablero como se muestra en la siguiente figura:

<img src="https://ivan-sipiran.com/downloads/tablero.png" alt= ‚Äú‚Äù width="100">

El modelo supone que si se apilan demasiados granos de arena en una celda, se produce un derrumbe. En particular, la regla es que si en una celda hay 4 o m√°s granos, se le quitan 4 granos, que se reparten equitativamente hacia las celdas vecinas en los cuatro puntos cardinales.

Para simular este proceso, supondremos que cada celda almacena un n√∫mero entero, que es la cantidad de granos almacenados en su interior. Aplicando la regla antes descrita (y suponiendo que las celdas que aparecen vac√≠as tienen cero granos), desde la configuraci√≥n

<img src="https://ivan-sipiran.com/downloads/tablero1.png" alt= ‚Äú‚Äù width="100">

se pasar√≠a a

<img src="https://ivan-sipiran.com/downloads/tablero2.png" alt= ‚Äú‚Äù width="100">

Cuando hay m√°s de una casilla con exceso de granos de arena, la regla se puede aplicar a ellas en cualquier orden y el resultado final es el mismo. Esta propiedad es la que hace que estas pilas de arena se llamen abelianas.

La idea es partir desde una configuraci√≥n inicial, y luego aplicar esta regla en todos los casilleros que se pueda, hasta que no quede ninguno que tenga 4 o m√°s granos de arena. Esa configuraci√≥n final la vamos a visualizar asignando un color distinto a cada n√∫mero de granos.

En particular, nos va a interesar estudiar lo que ocurre cuando la configuraci√≥n inicial tiene todas las celdas vac√≠as, excepto la del centro, en la cual hay $N$ granos de arena (donde $N$ es un par√°metro del problema).

Note que en teor√≠a el tablero es infinito en el sentido que siempre hay espacio para colocar los granos de arena que se van distribuyendo. Para su simulaci√≥n, usted debe calcular un tama√±o del tablero lo suficientemente grande como para estar seguro que ning√∫n grano de arena se salga hacia afuera de los bordes (calcule la m√°xima √°rea que se puede cubrir con $N$ granos de arena, y despu√©s calcule cuan grande debe ser el tablero  para poder contener esa √°rea).

# Tarea

## Parte 1
Usted debe escribir una funci√≥n en Python llamada ``arena``, tal que dado un valor de $N$, simule el proceso anteriormente descrito hasta que se estabilice. El programa debe contar e imprimir el n√∫mero total de veces que se aplic√≥ la regla que distribuye granos de arena hacia los vecinos. Adem√°s, debe visualizar en la pantalla el tablero resultante, usando los m√©todos que se describen m√°s adelante.

Por ejemplo, al simular con $N=10000$, la figura que resulta es

<img src="https://ivan-sipiran.com/downloads/tablero3.png" alt= ‚Äú‚Äù width="250">

La idea va a ser ejecutar la funci√≥n con un valor de $N$ dado por el profesor ($N=128$) y luego con valores crecientes de $N$, hasta el mayor n√∫mero que pueda alcanzar dentro de un tiempo de ejecuci√≥n razonable.

Escriba a continuaci√≥n la definici√≥n de su funci√≥n:
"""

import matplotlib.pyplot as plt
import numpy as np
import math
def arena(N):
  if N < 4:
    mat = np.zeros((3,3))
    mat[1][1] = N
    counter = 0
    print(counter)
    return mat
  counter = 0
  r = int(math.sqrt(N/math.pi))
  size = int(r*2) #aumentar el tama√±o del tablero
  mat = np.zeros((size,size))
  mat[r][r] = N
  p = len(mat)
  while mat.max() >= 4:
    for i in range(0,p):
      for j in range(0,p):
        if mat[i][j] >=4:
          if i < p-1:
            mat[i+1][j] += 1
          if i > 0:
            mat[i-1][j] += 1
          if j < p-1:
            mat[i][j+1] += 1
          if j > 0:
            mat[i][j-1] += 1
          mat[i][j] -= 4
        counter += 1
  print("Cantidad de iteraciones:",counter)
  return mat

"""Explique aqu√≠ c√≥mo calcul√≥ el tama√±o que necesita tener el tablero.

Como el arreglo tiene una forma final parecida a la de un c√≠rculo, se puede decir que la cantidad de casillas en un circulo est√° dada por la f√≥rmula: $\pi r^2$. Con esto, defin√≠ un r, correspondiente al radio del c√≠rculo, y aument√© el tama√±o del tablero de una manera conveniente, el doble, para que de esta manera no quede tan ajustado, al cual le asign√© el nombre "size". Luego defin√≠ la matriz de ceros con coordenadas ("i,j") = ("size","size").
Por otro lado, igual agregu√© un "caso base" para N<4, de tal manera que se tiene solamente una celda pintada al centro, ya que no se reparte ning√∫n grano de arena. Por esta raz√≥n defin√≠ la matriz (mat[1][1]).

Ahora ejecute la funci√≥n para $N=128$:
"""

print(arena(128))

"""A continuaci√≥n ejecute la funci√≥n para el valor m√°s grande de $N$ que consiga alcanzar en un tiempo razonable:"""

arena(11000) # reemplace N por el valor m√°ximo que alcanz√≥ a procesar
#se demora aprox 1 min 17 sg

"""## Parte 2
Observe que cuando en una celda hay un n√∫mero grande de granos de arena, es muy ineficiente ir quit√°ndole de 4 en 4, y ser√≠a mejor quitar de una sola vez lo m√°s que se pueda. Podemos mejorar nuestro programa si cambiamos la regla de distribuci√≥n, y decimos que si en una celda hay un n√∫mero de granos de arena mayor o igual a 4, le quitamos de una sola vez el mayor m√∫ltiplo de 4 posible, y todos esos granos lo repartimos equitativamente entre los vecinos de los cuatro puntos cardinales. Escriba una versi√≥n modificada de su funci√≥n de acuerdo a esta nueva regla.


"""

import matplotlib.pyplot as plt
import numpy as np
import math
def arena2(N):
  if N < 4:
    mat = np.zeros((3,3))
    mat[1][1] = N
    counter = 0
    print(counter)
    return mat
  counter = 0
  r = int(math.sqrt(N/math.pi))
  size = int(r*2) #aumentar el tama√±o del tablero
  mat = np.zeros((size,size))
  mat[r][r] = N
  p = len(mat)
  while mat.max() >= 4:
    for i in range(0,p):
      for j in range(0,p):
        if mat[i][j] >=4: #si la celda en cuestion es mayor a 4
          numgranos = (mat[i][j]//4) #cantidad de granos que deberian quedar al centro
          mat[i][j] -= numgranos * 4 #cantidad de granos que deben ser distribuidos a los vecinos
          if i < p-1:
            mat[i+1][j] += numgranos #se agrega a numgrains cantidad de granos que quedan en la celda vecina inmediatamente, no de 1 en 1 como antes.
          if i > 0:
            mat[i-1][j] += numgranos
          if j < p-1:
            mat[i][j+1] += numgranos
          if j > 0:
            mat[i][j-1] += numgranos
        counter += 1
  print("Cantidad de iteraciones:",counter)
  return mat

"""Ahora ejecute la funci√≥n para $N=128$:"""

arena2(128)

"""A continuaci√≥n ejecute la funci√≥n para el valor m√°s grande de  ùëÅ  que consiga alcanzar en un tiempo razonable. Note que √©ste n√∫mero no necesariamente es el mismo que para la funci√≥n anterior:"""

arena2(24000) # reemplace N por el valor m√°ximo que alcanz√≥ a procesar
#Se demora aprox 1 min 9 sg

"""## Parte 3
Compare a trav√©s de una tabla y un gr√°fico el n√∫mero de aplicaciones de la regla que hace el programa en la Parte 1 y el de la Parte 2, para los distintos valores de $N$ que usted haya calculado.

Discuta si vali√≥ la pena la optimizaci√≥n y discuta tambi√©n (pero no implemente) otras posibles optimizaciones que se le ocurran.
"""

#tabla con la cantidad de valores
import pandas as pd

df = pd.DataFrame()
#crear una lista del numero 0 al 130 para comparar datos
N = [30,128,500,1500,5000,10000]
arena_1 = [360,8496,156216,1621116,21890232,96526080]
arena_2 = [144,2304,25344,250488,3133260,12230400]

df['N'] = N
df['arena1'] = arena_1
df['arena2'] = arena_2

df.style

#Visualizaci√≥n gr√°fica del n√∫mero de aplicaciones de la regla que hace el programa en la parte 1 y en la parte 2 para los distintos valores de N
import matplotlib.pyplot as plt
plt.figure(figsize=(8,6))
N = [30,128,500,1500,5000,10000]
arena_1 = [360,8496,156216,1621116,21890232,96526080]
arena_2 = [144,2304,25344,250488,3133260,12230400]
plt.plot(N,arena_1,label='arena 1')
plt.plot(N,arena_2,label='arena 2')
plt.xlabel('Cantidad N de granos de arena')
plt.ylabel('Cantidad de iteraciones')
plt.title('Ciclos de reparticion de arena')
plt.legend()
plt.show()

"""Como se puede apreciar en el gr√°fico y en la tabla, la optimizaci√≥n hecha en arena 2 en comparaci√≥n con arena 1 es necesaria, ya que adem√°s de disminuir la cantidad de iteraciones del proceso, se reduce el tiempo en que termina de estabilizarse el c√≥digo.
Por otro lado, una posible optimizaci√≥n es disminuir el √°rea del tablero, ya sea multiplic√°ndolo por un n√∫mero menor a 2, o tambi√©n se puede ocupar una divisi√≥n entera "//" al escribir una expresi√≥n para "r", de esta manera se obtiene un √≠ndice m√°s exacto para la matriz de ceros.

# Visualizaci√≥n

Para la visualizaci√≥n se recomienda usar arreglos de Numpy y la librer√≠a Matplotlib. A continuaci√≥n un c√≥digo de ejemplo:
"""

import matplotlib.pyplot as plt
import numpy as np
#Para arena ejemplo con N=10000
mat = arena(10000)
plt.matshow(mat)
plt.show()
#Para arena 2 ejemplo con N=10000
mat = arena2(10000)
plt.matshow(mat)
plt.show()

"""## ¬øQu√© hay que entregar?

Usted debe crear una copia de este documento (del men√∫ seleccionar "Archivo" o "File" y de ahi la opci√≥n "guardar copia en Drive" o "save a copy in Drive"). Este nuevo documento (notebook de Colab) es el que debe modificar para luego compartirlo con la opci√≥n "Cualquier usuario de internet con este enlace puede ver esto" (o ‚ÄúAnyone on the internet with this link can view‚Äù). Esta opci√≥n se encuentra disponible en la parte superior derecha de su notebook, en el bot√≥n "Compartir" (o "Share"). Una vez que tenga disponible el enlace, colocarlo en la descripci√≥n de la entrega de su tarea. No olvide colocar su nombre dentro del notebook.
"""